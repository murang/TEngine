package main

import (
	"fmt"
	"io"
	"os"
	"strings"
	"text/template"

	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

const tmpl_cs = `// Code generated by gen_reg_cs. DO NOT EDIT.
using System;
using GameLogic;
using Pb;
using UnityEngine;

public class MsgReg
{
	[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]
	public static void RegisterAll()
	{
		{{- range . }}
		MsgMeta.RegisterMsgMeta((int)MsgId.{{ .Enum }}, typeof({{ .Message }}));
		{{- end }}
	}
}
`

func parseDescriptorFileCS(filename string) ([]int32, []string, []string, error) {
	// 读取描述符文件
	file, err := os.Open(filename)
	data, err := io.ReadAll(file)
	if err != nil {
		return nil, nil, nil, err
	}
	defer file.Close()

	var fileDescriptor descriptorpb.FileDescriptorSet
	if err := proto.Unmarshal(data, &fileDescriptor); err != nil {
		return nil, nil, nil, err
	}

	ids := make([]int32, 0, 32)
	idEnums := make([]string, 0, 32)
	msgs := make([]string, 0, 32)
	for _, fileDesc := range fileDescriptor.GetFile() {
		for _, enumDesc := range fileDesc.GetEnumType() {
			for _, valueDesc := range enumDesc.GetValue() {
				enumName := valueDesc.GetName()
				if enumName == "Unknown" {
					continue
				}
				parts := strings.Split(enumName, "_")
				var prefix = strings.ToUpper(parts[0])
				msgId := fmt.Sprintf("%s%s", prefix, parts[1])
				msgType := fmt.Sprintf("%s_%s", strings.ToUpper(parts[0]), parts[1])
				isMessageExist := false
				for _, msgDesc := range fileDesc.GetMessageType() {
					messageName := msgDesc.GetName()
					if messageName == msgType {
						isMessageExist = true
						break
					}
				}
				if !isMessageExist {
					panic(fmt.Sprintf("message %s not exist", msgType))
				}
				ids = append(ids, valueDesc.GetNumber())
				idEnums = append(idEnums, msgId)
				msgs = append(msgs, msgType)
			}
		}

	}
	return ids, idEnums, msgs, nil
}

func main() {
	descFile := "msg.desc"
	_, idEnums, msgs, err := parseDescriptorFileCS(descFile)
	if err != nil {
		fmt.Println("Error parsing descriptor file:", err)
		return
	}

	var data []struct {
		Enum    string
		Message string
	}
	for i, id := range idEnums {
		data = append(data, struct {
			Enum    string
			Message string
		}{Enum: id, Message: msgs[i]})
		println("MsgId:", data[i].Enum, "Massage:", data[i].Message)
	}

	t, err := template.New("code").Parse(tmpl_cs)
	if err != nil {
		fmt.Println("Error creating template:", err)
		return
	}

	// 注册消息
	file, err := os.Create("./cs/MsgRegistration.cs")
	if err != nil {
		fmt.Println("Error creating file:", err)
		return
	}
	defer file.Close()

	err = t.Execute(file, data)
	if err != nil {
		fmt.Println("Error executing template:", err)
		return
	}

	fmt.Println("Registration cs code generated successfully.")
}
